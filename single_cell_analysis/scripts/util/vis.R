# Qiwen Hu 2018
# core function for data visulization

clustering_perf_heatmap <- function(cluster_perf, type = "NMI", option = "real"){
  # Visulize the clustering performance using heatmap
  # Args
  #  cluster_perf: performance table
  #  type: evaluation metrics (NMI, ARI, average silhouette score)
  #  option: real/simulated indicates simulated or real datasets
  # Output:
  #  Heatmap figure in output directory
  
  output.dir <- file.path("figures", "model_eval")
  rownames(cluster_perf) <- cluster_perf$files
  
  if(option == "simulated"){
    # simulated parameters
    par <- c("celltypes", "ncell", "ngenes", "outlier")
    my_palette <- colorRampPalette(c("white", "blue"))(n = 50)
    
    for(i in 1:length(par)){
      # get performance metric for a specific parameter
      param_perf <- cluster_perf[grep(par[i], cluster_perf$files), ]
      param_perf$files <- gsub(paste(par[i], ".", sep = ""), 
                             "", param_perf$files)
      param_perf <- param_perf[order(as.numeric(param_perf$files)), ]
      
      pdf(file.path(output.dir, paste(par[i], type, "pdf", sep = ".")), width=7, height=5)
      gplots::heatmap.2(as.matrix(param_perf[, -1]), Rowv = FALSE, Colv = FALSE, dendrogram = "none",
              cellnote = param_perf[, -1], notecol = "black", notecex = 1,
              trace = "none", key = FALSE, margins = c(7, 5),
              cexRow=1, cexCol = 1, cex.main = 0.75, col = my_palette,
              lhei = c(0.75, 6), xlab = paste(par[i], type, sep = " "))
      dev.off()
    }
  } else if(option == "real"){
    pdf(file.path(output.dir, paste("real.data", type, "pdf", sep = ".")), width=10, height=8)
    gplots::heatmap.2(as.matrix(cluster_perf[, -1]), Rowv = FALSE, Colv = FALSE, dendrogram = "none",
                      cellnote = cluster_perf[, -1], notecol = "black", notecex = 1,
                      trace = "none", key = FALSE, margins = c(10, 8),
                      cexRow=1, cexCol = 1, cex.main = 0.75, col = my_palette, lhei=c(0.75, 6),
                      xlab = type) 
    dev.off()
  }
}

feature_vis <- function(feature_file, cellinfo, type = "tybalt_tsne_depth1", data = "real"){
  # This function is used to visualize the projected features into 2-dimensional space 
  # colored by celltypes
  # Args:
  #  type:
  #    - tybalt_tsne_depth1: projected features generated by tybalt with 1 hidden layer
  #    - tybalt_tsne_depth2: tybalt with 2 hidden layers
  #    - tybalt_tsne_depth3: tybalt with 3 hidden layers
  #    - rnaseq_tsne: projected features generated by t-SNE
  #    - umap: projected features generated by umap (https://github.com/lmcinnes/umap)
  #    - ZIFA: projected features generated by umap (https://github.com/epierson9/ZIFA)
  #    - pca: projected features generated by PCA
  #  cellinfo: file contains celltype information
  #  data: real/simulated
  # Output:
  #  return the ggplot object
  
  # get filename for a specific approach
  if(type == "tybalt_tsne_depth1"){
    feature_file <- feature_file[grep(".*depth1_.*tybalt_tsne.*", feature_file)]
  } else if(type == "tybalt_tsne_depth2"){
    feature_file <- feature_file[grep(".*depth2_.*tybalt_tsne.*", feature_file)]
  } else if(type == "tybalt_tsne_depth3"){
    feature_file <- feature_file[grep(".*depth3_.*tybalt_tsne.*", feature_file)]
  } else if(type == "rnaseq_tsne"){
    feature_file <- feature_file[grep(".*depth1_rnaseq_tsne.*", feature_file)]
  } else if(type == "umap"){
    feature_file <- feature_file[grep(".*rnaseq_umap.*", feature_file)]
  } else if(type == "ZIFA"){
    feature_file <- feature_file[grep(".*rnaseq_ZIFA.*", feature_file)]
  } else if(type == "pca"){
    feature_file <- feature_file[grep(".*pca.*", feature_file)]
  }
  
  # extract dataset information from filename
  dataset.info <- unlist(strsplit(feature_file, split = "[.]"))
  if(data == "simulated"){
    dataset <- paste(dataset.info[2], dataset.info[3], sep = ".")
  } else{
    dataset <- dataset.info[1]
  }
    
  # read file
  file <- read.table(file.path(input.dir, feature_file), header = TRUE,
                       sep = "\t")
  # get celltype information
  celltype <- read.table(file.path(input.dir, cellinfo), header = TRUE, 
                         sep = "\t")
  
  # add sample id into PCA file  
  if(type == "pca"){
    file <- cbind(rownames(file), file)
  }
  
  # add celltype information into file
  if(data == "simulated"){
    file <- cbind(file, celltype$Group)
  } else{
    file <- cbind(file, celltype$celltype)
  }
  colnames(file) <- c("id", "X1", "X2", "Group")
    
  # remove outlier for visulization. The parameters are defined based on X and Y distributions. 
  # only 1 - 2 datapoints are located ouside of this range.
  file <- file[file$X1 > -50 & file$X2 > -50, ]
  file <- file[file$X1 < 100 & file$X2 < 100, ]
    
  feature_plot <- ggplot2::ggplot(file, aes(X1, X2)) + 
    geom_point(aes(colour = factor(Group)), size = 1) + 
    ggtitle(paste(dataset, type, sep = ".")) + xlab("") + ylab("") + 
    ggplot2::theme_minimal() + ggplot2::theme(plot.title = element_text(hjust = 0.5))
    
 return(feature_plot)
}

Z_dm_perf_vis <- function(perf.table){
# Visulize performance (NMI/ARI) based on performance table after tuning Tybalt z parameters
# Args:
#  perf.table: performance table
# Returns:
#   ggplot object that summarize performance for different z parameters
  
  # modify table format for plotting
  cl.perf.trans <- dplyr::bind_cols(reshape2::melt(subset(cl.perf, select = nmi:ari)), 
                                    reshape2::melt(subset(cl.perf, select = nmi_var:ari_var)))
  cl.perf.trans <- dplyr::mutate(cl.perf.trans, dm = rep(cl.perf$dm, 2), dataset = rep(cl.perf$dataset, 2))
  colnames(cl.perf.trans) <- c("metrics", "value", "metric_var", "std", "dm", "dataset")
  
  #plot NMI and ARI for different z parameters
  # move them .05 to the left and right
  pd <- ggplot2::position_dodge(0.1) 
  
  p <- ggplot2::ggplot(cl.perf.trans, aes(x=dm, y=value, colour=metrics, group=metrics)) + 
    geom_errorbar(aes(ymin=value-std, ymax=value+std), width=.2, position=pd, colour="black") +
    geom_line(position=pd) + facet_wrap(~dataset) + geom_point(size=1.8) + 
    xlab("Z dimensions ") + theme_bw() 
  
  return(p)
}

learning_curve_plot <- function(filename, input.dir){
  # plot training/validation loss
  # Args:
  #  lc.table: data frame contains training and validation loss for each epoch
  #  filename: file name of lc.table
  # Returns:
  #  ggplot object that plot learning curve
  
  lc.table <- readr::read_tsv(file.path(input.dir, filename))
  # convert table format for ggplot2
  lc.perf <- lc.table %>% dplyr::select(loss, val_loss) %>% reshape2::melt()
  names(lc.perf) <- c("variable", "loss")
  lc.perf$epoch <- rep(seq(1, nrow(lc.table), 1), 2)
  
  filename <- gsub("_training.perf.tsv", "", filename)
  filename <- gsub(".exp.matrix.txt_", " ", filename)
  
  plot <- ggplot2::ggplot(lc.perf) + geom_line(aes(x = epoch, y = loss, color = variable)) + 
    labs(title = filename) + ggplot2::theme_minimal() + ggplot2::theme(plot.title = element_text(hjust = 0.5))
  
  return(plot)
}

confusion_matrix_vis <- function(confusion.matrix, option, dataset = "null"){
  # visulize confusion matrix
  # Args:
  #  confusion.matrix: confusion matrix get from an algorithm
  #  option: algorithm, eg. tybalt_depth3
  #  dataset: dataset name
  # Returns:
  #  ggplot of confusion matrix
  
  confusion.table <- reshape2::melt(confusion.matrix)
  colnames(confusion.table) <- c("True", "Predicted", "value")
  
  ggheatmap <- ggplot(data = confusion.table, aes(x = True, y = Predicted, fill = value)) + 
    geom_tile(color = "white") +
    scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                         midpoint = 0, limit = c(-1, 1), space = "Lab") +
    theme_minimal() + 
    theme(axis.text.x = element_text(angle = 45, vjust = 1, 
                                     size = 12, hjust = 1)) +
    coord_fixed() + 
    geom_text(aes(True, Predicted, label = value), color = "black", size = 4) + 
    ggtitle(paste(dataset, option))
  
  return(ggheatmap)
}

knn_perf_vis <- function(perf, simulated_or_real = "real"){
  # boxplot for knn performance visulization (accuracy)
  # Args:
  #  perf: knn performance table
  #  simulated_or_real: dataset type, e.g. simulated/real
  # Output:
  #  boxplot of knn accuracy plot
  output.dir <- file.path("figures", "model_eval")
  dataset <- unique(perf$dataset)
  p <- list()
  j <- 1
  for(i in 1:length(dataset)){
    data <- dplyr::filter(perf, dataset == dataset[i])
    p[[j]] <- ggplot2::ggplot(data, aes(x = approach, y = accuracy)) + 
      geom_errorbar(aes(ymin = accuracy - acc.sd, ymax = accuracy + acc.sd),
                    width=.2, size = .2) + 
      geom_point(size = 2) + theme_bw() + 
      ggtitle(dataset[i]) + 
      theme(axis.text.x = element_text(angle = 90, hjust = 1),
            plot.title = element_text(hjust = 0.5))
    
    # ouput 4 plots at a time
    if( j %% 4 == 0 ){
      cowplot::plot_grid(plotlist = p, ncol = 2)
      ggsave(file.path(output.dir, paste(simulated_or_real, "knn.acc", i, "pdf", sep = ".")), 
             width = 7, height = 6)
      p <- list()
      j <- 1
      next
    }
    j <- j + 1
  }
  # output the remaining plots
  if(i %%4 >0){
    cowplot::plot_grid(plotlist = p, ncol = i %% 4)
    ggsave(file.path(output.dir, paste(simulated_or_real, "knn.acc", i, "pdf", sep = ".")), 
         width = 7, height = 6)
  }
}
