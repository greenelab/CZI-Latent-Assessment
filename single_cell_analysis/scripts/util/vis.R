# Qiwen Hu 2018
# core function for data visulization

clustering_perf_heatmap <- function(cluster_perf, type = "NMI", option = "real"){
  # Visulize the clustering performance using heatmap
  # Args
  #  cluster_perf: performance table
  #  type: evaluation metrics (NMI, ARI, average silhouette score)
  #  option: real/simulated indicates simulated or real datasets
  # Output:
  #  Heatmap figure in output directory
  
  output.dir <- file.path("figures", "model_eval")
  rownames(cluster_perf) <- cluster_perf$files
  
  if(option == "simulated"){
    # simulated parameters
    par <- c("celltypes", "ncell", "ngenes", "outlier")
    my_palette <- colorRampPalette(c("white", "blue"))(n = 50)
    
    for(i in 1:length(par)){
      # get performance metric for a specific parameter
      param_perf <- cluster_perf[grep(par[i], cluster_perf$files), ]
      param_perf$files <- gsub(paste(par[i], ".", sep = ""), 
                             "", param_perf$files)
      param_perf <- param_perf[order(as.numeric(param_perf$files)), ]
      
      pdf(file.path(output.dir, paste(par[i], type, "pdf", sep = ".")), width=7, height=5)
      gplots::heatmap.2(as.matrix(param_perf[, -1]), Rowv = FALSE, Colv = FALSE, dendrogram = "none",
              cellnote = param_perf[, -1], notecol = "black", notecex = 1,
              trace = "none", key = FALSE, margins = c(7, 5),
              cexRow=1, cexCol = 1, cex.main = 0.75, col = my_palette,
              lhei = c(0.75, 6), xlab = paste(par[i], type, sep = " "))
      dev.off()
    }
  } else if(option == "real"){
    pdf(file.path(output.dir, paste("real.data", type, "pdf", sep = ".")), width=10, height=8)
    gplots::heatmap.2(as.matrix(cluster_perf[, -1]), Rowv = FALSE, Colv = FALSE, dendrogram = "none",
                      cellnote = cluster_perf[, -1], notecol = "black", notecex = 1,
                      trace = "none", key = FALSE, margins = c(10, 8),
                      cexRow=1, cexCol = 1, cex.main = 0.75, col = my_palette, lhei=c(0.75, 6),
                      xlab = type) 
    dev.off()
  }
}

feature_vis <- function(feature_file, cellinfo, type = "tybalt_tsne_depth1", data = "real"){
  # This function is used to visualize the projected features into 2-dimensional space 
  # colored by celltypes
  # Args:
  #  type:
  #    - tybalt_tsne_depth1: projected features generated by tybalt with 1 hidden layer
  #    - tybalt_tsne_depth2: tybalt with 2 hidden layers
  #    - tybalt_tsne_depth3: tybalt with 3 hidden layers
  #    - rnaseq_tsne: projected features generated by t-SNE
  #    - umap: projected features generated by umap (https://github.com/lmcinnes/umap)
  #    - ZIFA: projected features generated by umap (https://github.com/epierson9/ZIFA)
  #    - pca: projected features generated by PCA
  #  cellinfo: file contains celltype information
  #  data: real/simulated
  # Output:
  #  return the ggplot object
  
  # get filename for a specific approach
  if(type == "tybalt_tsne_depth1"){
    feature_file <- feature_file[grep(".*depth1_.*tybalt_tsne.*", feature_file)]
  } else if(type == "tybalt_tsne_depth2"){
    feature_file <- feature_file[grep(".*depth2_.*tybalt_tsne.*", feature_file)]
  } else if(type == "tybalt_tsne_depth3"){
    feature_file <- feature_file[grep(".*depth3_.*tybalt_tsne.*", feature_file)]
  } else if(type == "rnaseq_tsne"){
    feature_file <- feature_file[grep(".*depth1_rnaseq_tsne.*", feature_file)]
  } else if(type == "umap"){
    feature_file <- feature_file[grep(".*rnaseq_umap.*", feature_file)]
  } else if(type == "ZIFA"){
    feature_file <- feature_file[grep(".*rnaseq_ZIFA.*", feature_file)]
  } else if(type == "pca"){
    feature_file <- feature_file[grep(".*pca.*", feature_file)]
  }
  
  # extract dataset information from filename
  dataset.info <- unlist(strsplit(feature_file, split = "[.]"))
  if(data == "simulated"){
    dataset <- paste(dataset.info[2], dataset.info[3], sep = ".")
  } else{
    dataset <- dataset.info[1]
  }
    
  # read file
  file <- read.table(file.path(input.dir, feature_file), header = TRUE,
                       sep = "\t")
  # get celltype information
  celltype <- read.table(file.path(input.dir, cellinfo), header = TRUE, 
                         sep = "\t")
  
  # add sample id into PCA file  
  if(type == "pca"){
    file <- cbind(rownames(file), file)
  }
  
  # add celltype information into file
  if(data == "simulated"){
    file <- cbind(file, celltype$Group)
  } else{
    file <- cbind(file, celltype$celltype)
  }
  colnames(file) <- c("id", "X1", "X2", "Group")
    
  # remove outlier for visulization. The parameters are defined based on X and Y distributions. 
  # only 1 - 2 datapoints are located ouside of this range.
  file <- file[file$X1 > -50 & file$X2 > -50, ]
  file <- file[file$X1 < 100 & file$X2 < 100, ]
    
  feature_plot <- ggplot2::ggplot(file, aes(X1, X2)) + 
    geom_point(aes(colour = factor(Group)), size = 1) + 
    ggtitle(paste(dataset, type, sep = ".")) + xlab("") + ylab("") + 
    ggplot2::theme_minimal() + ggplot2::theme(plot.title = element_text(hjust = 0.5))
    
 return(feature_plot)
}

Z_dm_perf_vis <- function(perf.table){
# Visulize performance (NMI/ARI) based on performance table after tuning Tybalt z parameters
# Args:
#  perf.table: performance table
# Returns:
#   ggplot object that summarize performance for different z parameters
  
  # modify table format for plotting
  cl.perf.trans <- dplyr::bind_cols(reshape2::melt(subset(cl.perf, select = nmi:ari)), 
                                    reshape2::melt(subset(cl.perf, select = nmi_var:ari_var)))
  cl.perf.trans <- dplyr::mutate(cl.perf.trans, dm = rep(cl.perf$dm, 2), dataset = rep(cl.perf$dataset, 2))
  colnames(cl.perf.trans) <- c("metrics", "value", "metric_var", "std", "dm", "dataset")
  
  #plot NMI and ARI for different z parameters
  # move them .05 to the left and right
  pd <- ggplot2::position_dodge(0.1) 
  
  p <- ggplot2::ggplot(cl.perf.trans, aes(x=dm, y=value, colour=metrics, group=metrics)) + 
    geom_errorbar(aes(ymin=value-std, ymax=value+std), width=.2, position=pd, colour="black") +
    geom_line(position=pd) + facet_wrap(~dataset) + geom_point(size=1.8) + 
    xlab("Z dimensions ") + theme_bw() 
  
  return(p)
}




